#!/usr/bin/env python3
import sys
import re
from pathlib import Path

if len(sys.argv) != 3:
    print("Usage: generate_single_header.py <src_include_dir> <out_header>")
    sys.exit(2)

src_dir = Path(sys.argv[1]).resolve()
out_path = Path(sys.argv[2]).resolve()

if not src_dir.exists():
    print(f"Source include dir not found: {src_dir}")
    sys.exit(1)

out_path.parent.mkdir(parents=True, exist_ok=True)

# keep track of already inlined files to avoid duplication
inlined = set()

include_re = re.compile(r'^[ \t]*#\s*include\s*"([^"]+)"')
system_include_re = re.compile(r'^[ \t]*#\s*include\s*<([^>]+)>')
pragma_once_re = re.compile(r'^[ \t]*#\s*pragma\s+once')
ifndef_re = re.compile(r'^[ \t]*#\s*ifndef\s+(\w+)')
define_re = re.compile(r'^[ \t]*#\s*define\s+(\w+)')
endif_re = re.compile(r'^[ \t]*#\s*endif')

# Normalize path: try to resolve include path relative to current file, else relative to include root
def resolve_include(include_str, current_file):
    # try relative to current file
    candidate = (current_file.parent / include_str).resolve()
    if candidate.exists():
        return candidate

    # try relative to src_dir (which is include/koroutine). If include_str is like "koroutine/x.h",
    # also try stripping the leading directory name to match files placed under include/koroutine.
    candidate = (src_dir / include_str).resolve()
    if candidate.exists():
        return candidate

    include_root = src_dir.parent
    candidate = (include_root / include_str).resolve()
    if candidate.exists():
        return candidate

    # if include_str starts with the top-level namespace folder, strip first path component
    parts = include_str.split('/', 1)
    if len(parts) == 2:
        candidate = (src_dir / parts[1]).resolve()
        if candidate.exists():
            return candidate
        candidate = (include_root / parts[1]).resolve()
        if candidate.exists():
            return candidate

    # try absolute/relative path as-is
    candidate = Path(include_str)
    if candidate.exists():
        return candidate
    return None


# Read and inline a file
def inline_file(path, out_file):
    rp = str(path.resolve())
    if rp in inlined:
        out_file.write(f"// Skipping already inlined: {path.name}\n")
        return
    inlined.add(rp)

    out_file.write(f"// BEGIN INLINE: {path.relative_to(src_dir)}\n")
    with open(path, 'r', encoding='utf-8') as f:
        lines = f.readlines()

    # remove header guard if present
    i = 0
    n = len(lines)
    # skip leading comments and blank lines
    while i < n and lines[i].strip().startswith('//'):
        out_file.write(lines[i])
        i += 1

    # detect pragma once or ifndef/define guard
    skip_ifndef_define = None
    if i < n and pragma_once_re.match(lines[i]):
        i += 1
    else:
        # try ifndef/define
        if i + 1 < n:
            m1 = ifndef_re.match(lines[i])
            m2 = define_re.match(lines[i+1])
            if m1 and m2 and m1.group(1) == m2.group(1):
                skip_ifndef_define = m1.group(1)
                i += 2

    # process lines
    while i < n:
        line = lines[i]
        # if we hit an #endif that closes guard, skip it
        if skip_ifndef_define and endif_re.match(line):
            # naive: assume this is the closing endif for guard; skip and break
            i += 1
            break

        # handle includes
        m = include_re.match(line)
        if m:
            inc = m.group(1)
            resolved = resolve_include(inc, path)
            if resolved and resolved.resolve().is_file() and src_dir in resolved.parents:
                # inline project header
                inline_file(resolved, out_file)
            else:
                # leave include as-is (could be external header in project root)
                out_file.write(line)
            i += 1
            continue

        # keep system includes
        msys = system_include_re.match(line)
        if msys:
            out_file.write(line)
            i += 1
            continue

        # otherwise write line
        out_file.write(line)
        i += 1

    out_file.write(f"// END INLINE: {path.relative_to(src_dir)}\n\n")


# Entry: iterate all headers in src_dir in sorted order
headers = sorted([p for p in src_dir.rglob('*.h') if p.is_file()] + [p for p in src_dir.rglob('*.hpp') if p.is_file()])

with open(out_path, 'w', encoding='utf-8') as out:
    out.write("// Auto-generated single header file for Koroutine Library\n")
    out.write("// Generated by scripts/generate_single_header.py\n\n")
    # Optionally add a pragma once for the generated header
    out.write("#pragma once\n\n")

    for h in headers:
        inline_file(h, out)

print(f"Generated single header: {out_path}")
